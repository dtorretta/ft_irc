IRC Server Architecture Summary

  Let me explain your IRC server's architecture in a beginner-friendly way, covering the key concepts you need to understand.

  1. What is an IRC Server?

  An IRC (Internet Relay Chat) server is a program that allows multiple users to connect and chat in real-time. Think of it like a chat room system where:
  - Users connect with a client (like a chat app)
  - They can join channels (chat rooms)
  - They can send messages to channels or directly to other users
  - The server manages all connections and message routing

  2. Socket Programming Basics

  Your server uses sockets - these are like phone lines for computers:

  // Server creates a "listening" socket
  server_socket = socket(AF_INET, SOCK_STREAM, 0);  // Create socket
  bind(server_socket, address, size);               // Assign address/port
  listen(server_socket, max_connections);           // Start listening

  // When client connects:
  client_socket = accept(server_socket, ...);       // Accept new connection

  Key Concept: Each connected user gets their own socket (file descriptor), allowing the server to communicate with them individually.

  3. Event-Driven Architecture (Poll System)

  Your server uses polling instead of threads. Here's how it works:

  // Main server loop (Server.cpp:149-164)
  while (server_running) {
      poll(all_sockets, timeout);  // Wait for activity on ANY socket

      for each socket with activity:
          if (socket == server_socket)
              accept_new_client();     // Someone new connecting
          else
              handle_client_data();    // Existing client sent data
  }

  Why polling? Instead of creating a thread per client (expensive), we monitor all sockets at once and handle activity as it happens.

  4. Your Server's Core Components

  Server Class - The Main Controller

  class Server {
      std::vector<Client> clients;        // All connected users
      std::vector<Channel> channels;      // All chat rooms
      std::vector<pollfd> fds;           // Socket monitoring list
      int server_fdsocket;               // Main server socket
      std::string password;              // Server password
  };

  Client Class - Represents Each User

  class Client {
      int fd;                    // Their socket connection
      std::string nickname;      // Their chat name
      std::string username;      // Their username
      bool logedin;             // Did they authenticate?
      bool registered;          // Are they fully connected?
      std::string buffer;       // Incoming message storage
  };

  Channel Class - Represents Chat Rooms

  class Channel {
      std::string name;              // Channel name (like #general)
      std::vector<Client> clients;   // Regular users in channel
      std::vector<Client> admins;    // Channel operators (@users)
      std::string topic_name;        // Channel topic
      // Channel modes (invite-only, password, etc.)
  };

  5. IRC Protocol Basics

  IRC uses text commands sent over sockets. Every message ends with \r\n:

  Client sends: "PRIVMSG #general :Hello everyone!\r\n"
  Server responds: ":nick!user@host PRIVMSG #general :Hello everyone!\r\n"

  Message Format: COMMAND parameter1 parameter2 :message content

  6. Client Connection Flow

  When someone connects to your IRC server:

  1. Client connects → Socket created, added to polling list
  2. Client sends: "PASS secretpassword"  → Server checks password
  3. Client sends: "NICK john"            → Server sets nickname
  4. Client sends: "USER john 0 * :John"  → Server completes registration
  5. Now client can use commands like JOIN, PRIVMSG, etc.

  Authentication States:
  - Connected: Socket open, but not authenticated
  - Logged in: Password accepted (logedin = true)
  - Registered: NICK + USER complete (registered = true)

  7. Command Processing Pipeline

  Here's what happens when a client sends data:

  // 1. Raw data received from socket
  recv(client_socket, buffer, size);

  // 2. Add to client's buffer (messages might arrive in chunks)
  client->setBuffer(received_data);

  // 3. Check if we have complete messages (ending with \r\n)
  if (buffer.find("\r\n") != string::npos) {

      // 4. Split buffer into individual commands
      commands = split_recivedBuffer(buffer);

      // 5. Process each command
      for each command:
          parse_exec_cmd(command, client_fd);
  }

  8. Command Routing System

  Your server uses string comparison to route commands:

  void Server::parse_exec_cmd(string& cmd, int fd) {
      vector<string> args = split_cmd(cmd);  // ["PRIVMSG", "#general", "hello"]

      if (args[0] == "PRIVMSG")
          PRIVMSG(cmd, fd);
      else if (args[0] == "JOIN")
          JOIN(cmd, fd);
      else if (args[0] == "KICK")
          KICK(cmd, fd);
      // etc...
  }

  9. Error Handling & Responses

  IRC has standardized error codes:

  // Send error to client
  senderror(421, nickname, fd, " :Unknown command");
  // Results in: ":localhost 421 john BADCMD :Unknown command\r\n"

  // Send success response
  _sendResponse("PRIVMSG #general :Hello\r\n", fd);

  10. Channel Management

  Channels have two types of users:
  - Regular clients: Can chat, join/leave
  - Admins/Operators: Can kick users, change topic, set modes (shown with @ prefix)

  // Broadcasting to channel
  channel->sendTo_all(message);  // Sends to everyone in channel

  // Channel modes
  i = invite-only    k = password required    l = user limit
  t = topic restricted to ops    o = operator privilege

  Key Concepts for Command Implementation

  1. Always validate: Check if user is registered, parameters are correct
  2. Find objects: Use GetClient(fd), GetChannel(name) to find what you need
  3. Check permissions: Verify user can perform the action
  4. Send responses: Use proper IRC reply codes and formats
  5. Handle errors: Send appropriate error messages for failures
