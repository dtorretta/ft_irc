üñ• Qu√© es IRC
Es un protocolo, o sea, un conjunto de reglas que explican c√≥mo deben hablarse un cliente y un servidor para que se entiendan.


üîå C√≥mo funciona a nivel general
- Cliente IRC ‚Üí El programa que usa el usuario para conectarse y chatear (por ejemplo, irssi, HexChat, mIRC, etc.).
- Servidor IRC ‚Üí El programa que recibe y env√≠a mensajes entre todos los clientes.


El cliente env√≠a mensajes al servidor usando el protocolo IRC, y el servidor los retransmite a las personas o canales correctos.

üó£ El idioma de IRC: los mensajes
[:prefijo] COMANDO [param1] [param2] ... [:√∫ltimo par√°metro]

Prefijo (:prefijo) ‚Üí Opcional. Indica qui√©n env√≠a el mensaje (por ejemplo, :nick!user@host).
Comando ‚Üí Puede ser:
    Un comando textual (NICK, JOIN, PRIVMSG, PING‚Ä¶).
    Un c√≥digo num√©rico (por ejemplo, 001 significa "Welcome").
Par√°metros ‚Üí Datos adicionales que el comando necesita.
√öltimo par√°metro ‚Üí (opcional) ‚Üí todo lo que viene despu√©s de :, puede contener espacios (usado para texto de mensajes).

EJEMPLO de comandos basicos:

üìå NICK Dany --> Establecer o cambiar tu nickname
        Tu servidor debe:
            - Verificar que el nick no est√© en uso.
            - Guardar ese nick en la sesi√≥n del cliente.
            - Si est√° en uso, responder con un error:
                :server 433 * juan :Nickname is already in use

üìå USER Dany :Daniela Torretta     --> Registra informaci√≥n del usuario.
        Tu servidor debe:
            - Guardar estos datos en la estructura del cliente.
            - Solo permitir el registro completo cuando tenga NICK y USER definidos.

üìå JOIN #general --> Unirse a un canal
        Tu servidor debe:
            - Si el canal no existe, crearlo.
            - Agregar al usuario a la lista de miembros del canal.
            - Notificar al resto de usuarios en ese canal:
                :Dany!~user@host JOIN #general

üìå PRIVMSG #general :Hola a todos! --> Enviar mensaje a un canal
o
üìå PRIVMSG Miguel :¬øC√≥mo est√°s? --> Mensaje privado a un usuario
        Tu servidor debe:
            - Si el destino es un canal (#general), reenviar el mensaje a todos los miembros del canal (menos al emisor).
            - Si es un usuario (Miguel), enviar el mensaje solo a ese cliente

üìå QUIT :Nos vemos --> Salir el Servidor
        Tu servidor debe:
            - Notificar a todos los canales donde estaba el cliente que se fue. (tiene que mandar el mensaje "nos vemos" ?????)
            - Cerrar el socket del cliente.


üõ† 3. Lo que tu servidor tiene que hacer
Tu servidor IRC debe:

- Aceptar conexiones TCP de m√∫ltiples clientes a la vez.
- Leer mensajes que vengan del cliente y parsearlos (separar comando, par√°metros, texto).
- Actualizar el estado interno (lista de usuarios, canales, etc.).
- Responder seg√∫n el protocolo.
- Reenviar mensajes a otros clientes cuando sea necesario (por ejemplo, un PRIVMSG a todos en el canal).

PARSER
üõ† c√≥mo parsear un mensaje IRC
[:prefijo] COMANDO [params] ... [:trailing]    --> formato base

Ejemplo simple
    - PRIVMSG #general :Hola a todos

Cuando tu servidor recibe algo por socket (ej: con recv()), obtendr√°s una l√≠nea como:
"PRIVMSG #general :Hola a todos\r\n"         -- > "\r\n" !!

Pasos:

1. Quitar \r\n del final.
2. Separar prefix (si empieza con :) --> Si la primera letra es :, todo hasta el primer espacio es el prefix.
3. Separar comando -- > Lo siguiente hasta el primer espacio.
4. Separar par√°metros y trailing
    --> Lo que est√© antes de un : es lista de par√°metros (split por espacios).
    --> Lo que est√© despu√©s de : es el texto final (trailing).

PARAMS ES UN ARRAY YA QUE PUEDE HABER MAS DE UNO

cositas del subjet:

1)  No se espera que crees un programa para que el usuario chatee.
    Vas a probar tu servidor usando clientes reales ya existentes (ej: irssi, Weechat, HexChat).

2)  En IRC real, los servidores pueden conectarse entre s√≠ para formar redes.
    Ac√° solo implement√°s un servidor que maneja conexiones directas con clientes. Nada de enlazar con otro servidor.

3)  si un cliente se queda sin enviar nada, tu servidor no debe quedarse esperando indefinidamente y dejar colgados a los dem√°s.

4)  No pod√©s usar fork() para crear un proceso por cliente
    En cambio, vas a usar un √∫nico proceso y todos los sockets van a estar en modo no bloqueante
    (fcntl(fd, F_SETFL, O_NONBLOCK) por ejemplo).                --->> KHEEEEEEEEE
    ‚ÄúNo bloqueante‚Äù significa que funciones como recv() o send() no se quedan esperando si no hay datos.
    Si no hay nada que leer/escribir, devuelven inmediatamente.

5)  Ten√©s que manejar todas las operaciones con un √∫nico llamado a poll() (o select(), epoll(), kqueue() si prefer√≠s).
    Esto incluye:
        - Aceptar nuevas conexiones (listen() / accept()).
        - Leer datos (recv()).
        - Enviar datos (send()).
    O sea, todo pasa por el mismo bucle de eventos que revisa qu√© sockets est√°n listos para operar.
    SIEMPRE que hagamos read/recv o write/send tenemos que verificar antes con un poll() si hay datos para leer/escribir

6)  Elegir un clientes IRC (WeeChat, HexChat, irssi, mIRC‚Ä¶) y usarlo como ‚Äúcliente oficial‚Äù para probar tu servidor.


üí° En resumen:
Vas a tener un √∫nico bucle principal m√°s o menos as√≠:

while (true)
{
    poll(fds, nfds, timeout); // espera hasta que haya algo listo
    for (cada fd listo)
    {
        if (fd == listening_socket) accept();
        else if (fd listo para lectura) recv();
        else if (fd listo para escritura) send();
    }
}

1Ô∏è‚É£ ¬øQu√© es poll()?
poll() es una syscall que revisa un conjunto de file descriptors y te dice cu√°les est√°n listos
    ‚ÄúAvisame cuando alguno de estos file descriptors est√© listo para hacer algo (leer, escribir, o me avise de un error)‚Äù.

en poll el fds es un array de fds que contiene:
- El socket que escucha conexiones nuevas (listening_socket). --> para saber cu√°ndo llega un nuevo cliente
- Todos los sockets de clientes conectados. --> los sockets nuevos creados por accept()
- Cualquier otro descriptor que quieras vigilar (pipes internos, etc.)

Un socket es simplemente un canal de comunicaci√≥n entre dos programas (cliente y servidor)

Los sockets permiten: comunicacion en tiempo real entre servidor y cliente, de esta forma, ante cuando nueva actualizacion,
el server puede enviar una notificacion y comunicar al cliente

Antes de los sockets (o sin ellos), para que un cliente ‚Äúse entere‚Äù si hay algo nuevo en el servidor,
normalmente hac√≠a peticiones peri√≥dicas (polling): preguntaba cada X segundos si hab√≠a novedades.

En el sistema operativo, cada socket est√° representado por un descriptor de archivo (FD)
(un n√∫mero entero que usa tu programa para leer y escribir datos).

1. Listening socket = un fd que est√° ‚Äúescuchando‚Äù conexiones nuevas. Est√° esperando activamente a que un cliente intente conectarse.+
2. Cuando un cliente se conecta, el servidor llama a accept()
    - accept() no crea un nuevo listening socket.
    Lo que hace es generar un nuevo socket (un nuevo fd) que representa la conexi√≥n espec√≠fica con ese cliente.
    Este nuevo socket es el que usas para leer y escribir datos con ese cliente.
3. ¬øQu√© pasa con el listening socket despu√©s de accept()?
    - El listening socket sigue existiendo y sigue escuchando para futuras conexiones entrantes.

Para evaluacion:
1. netcat (nc) - BEST for evaluation

  nc localhost 6667
  Why it's perfect:
  - ‚úÖ Shows raw IRC protocol - evaluators see exactly what your server sends/receives
  - ‚úÖ No client-side filtering - you see every response your server generates
  - ‚úÖ Simple and direct - no GUI complications
  - ‚úÖ Available everywhere - works on all systems
  - ‚úÖ Transparent - evaluators can see the actual IRC messages

    Use netcat for evaluation because:
  1. Evaluators can see your JOIN message format: :alice!alice@127.0.0.1 JOIN #test
  2. They see your error handling: : 403 bob #nonexistent :Channel does not exist
  3. Shows your PART implementation: :bob!~bob@localhost PART #test :reason
  4. Demonstrates raw IRC protocol compliance
