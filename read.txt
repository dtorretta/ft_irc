üñ• Qu√© es IRC
Es un protocolo, o sea, un conjunto de reglas que explican c√≥mo deben hablarse un cliente y un servidor para que se entiendan.


üîå C√≥mo funciona a nivel general
- Cliente IRC ‚Üí El programa que usa el usuario para conectarse y chatear (por ejemplo, irssi, HexChat, mIRC, etc.).
- Servidor IRC ‚Üí El programa que recibe y env√≠a mensajes entre todos los clientes.


El cliente env√≠a mensajes al servidor usando el protocolo IRC, y el servidor los retransmite a las personas o canales correctos.

üó£ El idioma de IRC: los mensajes
[:prefijo] COMANDO [param1] [param2] ... [:√∫ltimo par√°metro]

Prefijo (:prefijo) ‚Üí Opcional. Indica qui√©n env√≠a el mensaje (por ejemplo, :nick!user@host).
Comando ‚Üí Puede ser:
    Un comando textual (NICK, JOIN, PRIVMSG, PING‚Ä¶).
    Un c√≥digo num√©rico (por ejemplo, 001 significa "Welcome").
Par√°metros ‚Üí Datos adicionales que el comando necesita.
√öltimo par√°metro ‚Üí (opcional) ‚Üí todo lo que viene despu√©s de :, puede contener espacios (usado para texto de mensajes).

EJEMPLO de comandos basicos:

üìå NICK Dany --> Establecer o cambiar tu nickname
        Tu servidor debe:
            - Verificar que el nick no est√© en uso.
            - Guardar ese nick en la sesi√≥n del cliente.
            - Si est√° en uso, responder con un error:   
                :server 433 * juan :Nickname is already in use

üìå USER Dany :Daniela Torretta     --> Registra informaci√≥n del usuario.
        Tu servidor debe:
            - Guardar estos datos en la estructura del cliente.
            - Solo permitir el registro completo cuando tenga NICK y USER definidos.

üìå JOIN #general --> Unirse a un canal
        Tu servidor debe:
            - Si el canal no existe, crearlo.
            - Agregar al usuario a la lista de miembros del canal.
            - Notificar al resto de usuarios en ese canal:
                :Dany!~user@host JOIN #general

üìå PRIVMSG #general :Hola a todos! --> Enviar mensaje a un canal
o
üìå PRIVMSG Miguel :¬øC√≥mo est√°s? --> Mensaje privado a un usuario
        Tu servidor debe:
            - Si el destino es un canal (#general), reenviar el mensaje a todos los miembros del canal (menos al emisor).
            - Si es un usuario (Miguel), enviar el mensaje solo a ese cliente

üìå QUIT :Nos vemos --> Salir el Servidor
        Tu servidor debe:
            - Notificar a todos los canales donde estaba el cliente que se fue. (tiene que mandar el mensaje "nos vemos" ?????)
            - Cerrar el socket del cliente.


üõ† 3. Lo que tu servidor tiene que hacer
Tu servidor IRC debe:

- Aceptar conexiones TCP de m√∫ltiples clientes a la vez.
- Leer mensajes que vengan del cliente y parsearlos (separar comando, par√°metros, texto).
- Actualizar el estado interno (lista de usuarios, canales, etc.).
- Responder seg√∫n el protocolo.
- Reenviar mensajes a otros clientes cuando sea necesario (por ejemplo, un PRIVMSG a todos en el canal).

PARSER
üõ† c√≥mo parsear un mensaje IRC 
[:prefijo] COMANDO [params] ... [:trailing]    --> formato base

Ejemplo simple
    - PRIVMSG #general :Hola a todos

Cuando tu servidor recibe algo por socket (ej: con recv()), obtendr√°s una l√≠nea como:
"PRIVMSG #general :Hola a todos\r\n"         -- > "\r\n" !!

Pasos:

1. Quitar \r\n del final.
2. Separar prefix (si empieza con :) --> Si la primera letra es :, todo hasta el primer espacio es el prefix.
3. Separar comando -- > Lo siguiente hasta el primer espacio.
4. Separar par√°metros y trailing
    --> Lo que est√© antes de un : es lista de par√°metros (split por espacios).
    --> Lo que est√© despu√©s de : es el texto final (trailing).

PARAMS ES UN ARRAY YA QUE PUEDE HABER MAS DE UNO

cositas del subjet:

1)  No se espera que crees un programa para que el usuario chatee.
    Vas a probar tu servidor usando clientes reales ya existentes (ej: irssi, Weechat, HexChat).
    
2)  En IRC real, los servidores pueden conectarse entre s√≠ para formar redes.
    Ac√° solo implement√°s un servidor que maneja conexiones directas con clientes. Nada de enlazar con otro servidor.

3)  si un cliente se queda sin enviar nada, tu servidor no debe quedarse esperando indefinidamente y dejar colgados a los dem√°s.

4)  No pod√©s usar fork() para crear un proceso por cliente
    En cambio, vas a usar un √∫nico proceso y todos los sockets van a estar en modo no bloqueante 
    (fcntl(fd, F_SETFL, O_NONBLOCK) por ejemplo).                --->> KHEEEEEEEEE
    ‚ÄúNo bloqueante‚Äù significa que funciones como recv() o send() no se quedan esperando si no hay datos. 
    Si no hay nada que leer/escribir, devuelven inmediatamente.
    
5)  Ten√©s que manejar todas las operaciones con un √∫nico llamado a poll() (o select(), epoll(), kqueue() si prefer√≠s).
    Esto incluye:
        - Aceptar nuevas conexiones (listen() / accept()).
        - Leer datos (recv()).  
        - Enviar datos (send()).
    O sea, todo pasa por el mismo bucle de eventos que revisa qu√© sockets est√°n listos para operar.
    SIEMPRE que hagamos read/recv o write/send tenemos que verificar antes con un poll() si hay datos para leer/escribir

üí° En resumen:
Vas a tener un √∫nico bucle principal m√°s o menos as√≠:

while (true) 
{
    poll(fds, nfds, timeout); // espera hasta que haya algo listo
    for (cada fd listo) 
    {
        if (fd == listening_socket) accept();
        else if (fd listo para lectura) recv();
        else if (fd listo para escritura) send();
    }
}

1Ô∏è‚É£ ¬øQu√© es poll()?
poll() es una syscall que le pide al kernel:
    ‚ÄúAvisame cuando alguno de estos file descriptors est√© listo para hacer algo (leer, escribir, o me avise de un error)‚Äù.
    
6)  Elegir un clientes IRC (WeeChat, HexChat, irssi, mIRC‚Ä¶) y usarlo como ‚Äúcliente oficial‚Äù para probar tu servidor.