üñ• Qu√© es IRC
Es un protocolo, o sea, un conjunto de reglas que explican c√≥mo deben hablarse un cliente y un servidor para que se entiendan.


üîå C√≥mo funciona a nivel general
- Cliente IRC ‚Üí El programa que usa el usuario para conectarse y chatear (por ejemplo, irssi, HexChat, mIRC, etc.).
- Servidor IRC ‚Üí El programa que recibe y env√≠a mensajes entre todos los clientes.


El cliente env√≠a mensajes al servidor usando el protocolo IRC, y el servidor los retransmite a las personas o canales correctos.

üó£ El idioma de IRC: los mensajes
[:prefijo] COMANDO [param1] [param2] ... [:√∫ltimo par√°metro]

Prefijo (:prefijo) ‚Üí Opcional. Indica qui√©n env√≠a el mensaje (por ejemplo, :nick!user@host).
Comando ‚Üí Puede ser:
    Un comando textual (NICK, JOIN, PRIVMSG, PING‚Ä¶).
    Un c√≥digo num√©rico (por ejemplo, 001 significa "Welcome").
Par√°metros ‚Üí Datos adicionales que el comando necesita.
√öltimo par√°metro ‚Üí (opcional) ‚Üí todo lo que viene despu√©s de :, puede contener espacios (usado para texto de mensajes).

EJEMPLO de comandos basicos:

üìå NICK Dany --> Establecer o cambiar tu nickname
        Tu servidor debe:
            - Verificar que el nick no est√© en uso.
            - Guardar ese nick en la sesi√≥n del cliente.
            - Si est√° en uso, responder con un error:
                :server 433 * juan :Nickname is already in use

üìå USER Dany :Daniela Torretta     --> Registra informaci√≥n del usuario.
        Tu servidor debe:
            - Guardar estos datos en la estructura del cliente.
            - Solo permitir el registro completo cuando tenga NICK y USER definidos.

üìå JOIN #general --> Unirse a un canal
        Tu servidor debe:
            - Si el canal no existe, crearlo.
            - Agregar al usuario a la lista de miembros del canal.
            - Notificar al resto de usuarios en ese canal:
                :Dany!~user@host JOIN #general

üìå PRIVMSG #general :Hola a todos! --> Enviar mensaje a un canal
o
üìå PRIVMSG Miguel :¬øC√≥mo est√°s? --> Mensaje privado a un usuario
        Tu servidor debe:
            - Si el destino es un canal (#general), reenviar el mensaje a todos los miembros del canal (menos al emisor).
            - Si es un usuario (Miguel), enviar el mensaje solo a ese cliente

üìå QUIT :Nos vemos --> Salir el Servidor
        Tu servidor debe:
            - Notificar a todos los canales donde estaba el cliente que se fue. (tiene que mandar el mensaje "nos vemos" ?????)
            - Cerrar el socket del cliente.


üõ† 3. Lo que tu servidor tiene que hacer
Tu servidor IRC debe:

- Aceptar conexiones TCP de m√∫ltiples clientes a la vez.
- Leer mensajes que vengan del cliente y parsearlos (separar comando, par√°metros, texto).
- Actualizar el estado interno (lista de usuarios, canales, etc.).
- Responder seg√∫n el protocolo.
- Reenviar mensajes a otros clientes cuando sea necesario (por ejemplo, un PRIVMSG a todos en el canal).

PARSER
üõ† c√≥mo parsear un mensaje IRC
[:prefijo] COMANDO [params] ... [:trailing]    --> formato base

Ejemplo simple
    - PRIVMSG #general :Hola a todos

Cuando tu servidor recibe algo por socket (ej: con recv()), obtendr√°s una l√≠nea como:
"PRIVMSG #general :Hola a todos\r\n"         -- > "\r\n" !!

Pasos:

1. Quitar \r\n del final.
2. Separar prefix (si empieza con :) --> Si la primera letra es :, todo hasta el primer espacio es el prefix.
3. Separar comando -- > Lo siguiente hasta el primer espacio.
4. Separar par√°metros y trailing
    --> Lo que est√© antes de un : es lista de par√°metros (split por espacios).
    --> Lo que est√© despu√©s de : es el texto final (trailing).

PARAMS ES UN ARRAY YA QUE PUEDE HABER MAS DE UNO

cositas del subjet:

1)  No se espera que crees un programa para que el usuario chatee.
    Vas a probar tu servidor usando clientes reales ya existentes (ej: irssi, Weechat, HexChat).

2)  En IRC real, los servidores pueden conectarse entre s√≠ para formar redes.
    Ac√° solo implement√°s un servidor que maneja conexiones directas con clientes. Nada de enlazar con otro servidor.

3)  si un cliente se queda sin enviar nada, tu servidor no debe quedarse esperando indefinidamente y dejar colgados a los dem√°s.

4)  No pod√©s usar fork() para crear un proceso por cliente
    En cambio, vas a usar un √∫nico proceso y todos los sockets van a estar en modo no bloqueante
    (fcntl(fd, F_SETFL, O_NONBLOCK) por ejemplo).                --->> KHEEEEEEEEE
    ‚ÄúNo bloqueante‚Äù significa que funciones como recv() o send() no se quedan esperando si no hay datos.
    Si no hay nada que leer/escribir, devuelven inmediatamente.

5)  Ten√©s que manejar todas las operaciones con un √∫nico llamado a poll() (o select(), epoll(), kqueue() si prefer√≠s).
    Esto incluye:
        - Aceptar nuevas conexiones (listen() / accept()).
        - Leer datos (recv()).
        - Enviar datos (send()).
    O sea, todo pasa por el mismo bucle de eventos que revisa qu√© sockets est√°n listos para operar.
    SIEMPRE que hagamos read/recv o write/send tenemos que verificar antes con un poll() si hay datos para leer/escribir

6)  Elegir un clientes IRC (WeeChat, HexChat, irssi, mIRC‚Ä¶) y usarlo como ‚Äúcliente oficial‚Äù para probar tu servidor.


üí° En resumen:
Vas a tener un √∫nico bucle principal m√°s o menos as√≠:

while (true)
{
    poll(fds, nfds, timeout); // espera hasta que haya algo listo
    for (cada fd listo)
    {
        if (fd == listening_socket) accept();
        else if (fd listo para lectura) recv();
        else if (fd listo para escritura) send();
    }
}

1Ô∏è‚É£ ¬øQu√© es poll()?
poll() es una syscall que revisa un conjunto de file descriptors y te dice cu√°les est√°n listos
    ‚ÄúAvisame cuando alguno de estos file descriptors est√© listo para hacer algo (leer, escribir, o me avise de un error)‚Äù.

en poll el fds es un array de fds que contiene:
- El socket que escucha conexiones nuevas (listening_socket). --> para saber cu√°ndo llega un nuevo cliente
- Todos los sockets de clientes conectados. --> los sockets nuevos creados por accept()
- Cualquier otro descriptor que quieras vigilar (pipes internos, etc.)

Un socket es simplemente un canal de comunicaci√≥n entre dos programas (cliente y servidor)

Los sockets permiten: comunicacion en tiempo real entre servidor y cliente, de esta forma, ante cuando nueva actualizacion,
el server puede enviar una notificacion y comunicar al cliente

Antes de los sockets (o sin ellos), para que un cliente ‚Äúse entere‚Äù si hay algo nuevo en el servidor,
normalmente hac√≠a peticiones peri√≥dicas (polling): preguntaba cada X segundos si hab√≠a novedades.

En el sistema operativo, cada socket est√° representado por un descriptor de archivo (FD)
(un n√∫mero entero que usa tu programa para leer y escribir datos).

1. Listening socket = un fd que est√° ‚Äúescuchando‚Äù conexiones nuevas. Est√° esperando activamente a que un cliente intente conectarse.+
2. Cuando un cliente se conecta, el servidor llama a accept()
    - accept() no crea un nuevo listening socket.
    Lo que hace es generar un nuevo socket (un nuevo fd) que representa la conexi√≥n espec√≠fica con ese cliente.
    Este nuevo socket es el que usas para leer y escribir datos con ese cliente.
3. ¬øQu√© pasa con el listening socket despu√©s de accept()?
    - El listening socket sigue existiendo y sigue escuchando para futuras conexiones entrantes.
port.find_first_not_of("0123456789") == std::string::npos
- Busca en el string port el primer car√°cter que NO sea un d√≠gito del 0 al 9.
- Si no encuentra ning√∫n car√°cter que no sea d√≠gito, devuelve std::string::npos.

find_first_of("0123456789") == std::string::npos
- Busca en el string el primer car√°cter que SI est√© dentro del conjunto "0123456789" (es decir, el primer d√≠gito)
- Si no encuentra ning√∫n d√≠gito, devuelve std::string::npos.

 find("\r\n") vs  find_first_of("\r\n")
1. find Busca la subcadena exacta "\r\n"
2. find_first_of busca un '\r' o un '\n'.


Para evaluacion:
1. netcat (nc) - BEST for evaluation

  nc localhost 6667
  Why it's perfect:
  - ‚úÖ Shows raw IRC protocol - evaluators see exactly what your server sends/receives
  - ‚úÖ No client-side filtering - you see every response your server generates
  - ‚úÖ Simple and direct - no GUI complications
  - ‚úÖ Available everywhere - works on all systems
  - ‚úÖ Transparent - evaluators can see the actual IRC messages

    Use netcat for evaluation because:
  1. Evaluators can see your JOIN message format: :alice!alice@127.0.0.1 JOIN #test
  2. They see your error handling: : 403 bob #nonexistent :Channel does not exist
  3. Shows your PART implementation: :bob!~bob@localhost PART #test :reason
  4. Demonstrates raw IRC protocol compliance






mapeos:

HEADER:
public:
typedef void (Server::*CommandHandler)(std::string, int);

private:        
std::map<KEY, VALUE> _NAME; 
std::map<std::string, CommandHandler> _registrationCommands; 


PRIMERO PUBLIC Y DESPUES PRIVATE


INIT:
_registrationCommands["NICK"] = &Server::NICK;

EJECUCION:
//1
std::string cmdName = commands[0];   --> almacena el nombre de la primera key

//2 --> definir el iterador donde find busca en el std::map si existe la key cmdName (ej: "NICK").
std::map<KEY, VALUE>::iterator it = _NAME.find(cmdName);
std::map<std::string, CommandHandler>::iterator it = _registrationCommands.find(cmdName);

//3
if (it != _registrationCommands.end()) 
{
    CommandHandler handler = it->second; //es lo mismo que poner _registrationCommands[cmdName]
    (this->*handler)(cmd, fd);  //handler es simplemente el nombre
    return;
}


-first = std::string --> KEY
-second = CommandHandler --> VALUE

'it->second' es lo mismo que hacer '_NAME[cmdName]' ya que map[key] devuelve una referencia al value asociado a esa key

(this->*handler)
handler es un puntero '*handler' a la funcion 'value / second' que esta declarada en la clase server por eso la llamados con 'this->'


------------

/*

setters:

- usamos & para evitar hace4r una copia extra cuando lo pasamos omo parametro.
    De todos modos al hacer '_cmd = cmds' vamos a guardar una copia
- usamos const que significa que dentro del setter no pod√©s modificar el par√°metro cmds.
    Asignar (copiar) no es modificar el objeto original, es crear una copia interna.


    Tipos primitivos (int, char, bool, etc.) ‚Üí pasarlos por valor normal. (nousamos const ni &)


*/



/*
Cuando recv() no ley√≥ todo el mensaje porque el buffer es limitado (ejemplo 1024 bytes) y quedaron datos sin leer, 
esos datos ya est√°n en el buffer interno del sistema operativo (SO) para esa conexi√≥n TCP.

Entonces:

Aunque el cliente no haya enviado m√°s datos nuevos,
El socket sigue teniendo datos pendientes en su cola interna (buffer del SO) que todav√≠a no le√≠ste,
Por eso, en la siguiente llamada a poll(), el descriptor del socket sigue marc√°ndose con POLLIN, indicando que hay datos para leer,
Y al llamar a recv() de nuevo, obtendr√°s el siguiente fragmento del mensaje.


Cliente env√≠a datos ‚Üí llegan al buffer interno del socket en el servidor.
poll() ‚Üí detecta que hay datos (POLLIN).
recv() ‚Üí lees N bytes (por ejemplo 1024), y esos N bytes se eliminan del buffer interno del SO.
Si qued√≥ m√°s en el buffer, poll volver√° a marcar POLLIN en el siguiente ciclo, incluso si el cliente ya no manda nada m√°s.
Cuando lees todo (el buffer interno queda vac√≠o),
	poll ya no detecta datos ‚Üí no se ejecuta NewData() hasta que lleguen m√°

*/


dentro de init --> struct sockaddr_in addr;

	//al crear un socket se necesita crear un nuevo elemento de la estructura sockaddr_in para indicar a qu√© direcci√≥n IP y puerto se debe ‚Äúatar‚Äù ese socket
	//solo en estos casos, definimos tambien los elementos de addr, necesarios para usar 'bind' (en el caso de clientes nuevos omitimos esto)
	//Esta estructura es la manera que el sistema operativo usa para representar direcciones de red IPv4 en C/C++
	struct sockaddr_in addr;